<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Royale‑Inspired — Arena + Smarter AI</title>
  <style>
    :root{--bg:#071022;--panel:#0b1220;--accent:#ffd166;--muted:#94a3b8;--river:#0b3a4b;--bridge:#8b6a3b;--player:#2dd4bf;--enemy:#fb7185}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#041622 0%, #071428 100%);color:#e6eef8}
    #game-wrap{width:100%;height:100vh;position:relative;overflow:hidden}
    canvas{display:block;width:100%;height:100%}
    .hud{position:absolute;left:12px;right:12px;top:12px;display:flex;justify-content:space-between;pointer-events:none}
    .panel{background:rgba(6,10,14,0.45);backdrop-filter:blur(6px);padding:8px;border-radius:10px;pointer-events:auto}
    .cards{position:absolute;left:50%;transform:translateX(-50%);bottom:12px;display:flex;gap:10px}
    .card{width:88px;height:120px;border-radius:10px;background:linear-gradient(180deg,#0e2130,#0c1620);display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:pointer;box-shadow:0 6px 18px rgba(2,6,23,0.6);border:1px solid rgba(255,255,255,0.03)}
    .card .cost{position:absolute;left:8px;top:8px;background:rgba(0,0,0,0.48);padding:6px;border-radius:10px;font-weight:700}
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:20}
    .menu{width:560px;padding:30px;border-radius:12px;background:linear-gradient(180deg,#071129,#071428);box-shadow:0 12px 40px rgba(2,6,23,0.7);text-align:center}
    .btn{display:inline-flex;padding:12px 18px;border-radius:10px;background:linear-gradient(180deg,#ffd166,#fca311);color:#08131b;font-weight:700;border:none;cursor:pointer}
    .popup{position:absolute;left:50%;top:40%;transform:translate(-50%,-50%);background:linear-gradient(180deg,#081428,#071022);padding:24px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);display:none;z-index:30}
    @media (max-width:720px){.card{width:72px;height:104px}.menu{width:92%}}
  </style>
</head>
<body>
  <div id="game-wrap">
    <canvas id="game"></canvas>

    <div class="hud">
      <div class="panel left">
        <div>Player Tower <span id="playerTowerHP">1000</span></div>
      </div>
      <div class="panel center">
        <div style="display:flex;align-items:center;gap:12px">
          <div style="min-width:220px">
            <div style="font-size:12px;color:var(--muted)">Elixir</div>
            <div style="height:12px;background:rgba(255,255,255,0.06);border-radius:8px;overflow:hidden;width:220px"><div id="elixirBar" style="height:100%;width:40%;background:linear-gradient(90deg,#06b6d4,#0891b2)"></div></div>
          </div>
          <div class="panel" style="padding:6px;border-radius:8px" id="elixirValue">4</div>
        </div>
      </div>
      <div class="panel right">
        <div>AI Tower <span id="aiTowerHP">1000</span></div>
      </div>
    </div>

    <div class="cards" id="cards"></div>

    <div class="overlay" id="menuOverlay">
      <div class="menu">
        <h1>Royale‑Inspired Arena</h1>
        <p>An enhanced arena: river, two bridges and three crossing lanes. Smarter AI and improved placement. Still fully original assets.</p>
        <button class="btn" id="startBtn">Play vs AI</button>
      </div>
    </div>

    <div class="popup panel" id="gameOverPopup">
      <h2 id="resultTitle">Victory!</h2>
      <p id="resultText"></p>
      <div style="margin-top:12px"><button class="btn" id="restartBtn">Play again</button></div>
    </div>

  </div>

  <script>
  // -------------------- Setup --------------------
  const canvas = document.getElementById('game'); const ctx = canvas.getContext('2d');
  function resize(){ canvas.width = Math.floor(window.innerWidth * devicePixelRatio); canvas.height = Math.floor(window.innerHeight * devicePixelRatio); canvas.style.width = window.innerWidth+'px'; canvas.style.height = window.innerHeight+'px'; ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0); }
  window.addEventListener('resize', resize); resize();

  // arena layout: river across middle, two bridges
  let W = canvas.width/devicePixelRatio, H = canvas.height/devicePixelRatio;
  function recompute(){ W = canvas.width/devicePixelRatio; H = canvas.height/devicePixelRatio; BRIDGE_WIDTH = Math.max(88, W*0.12); BRIDGE_GAP = Math.max(140, W*0.06); riverY = H/2; leftBridgeX = W*0.25; rightBridgeX = W*0.75; laneYs = [riverY - 90, riverY, riverY + 90]; spawnZonePlayerY = H*0.6; spawnZoneAIY = H*0.4; }
  window.addEventListener('resize', recompute); recompute();

  // game state
  let elixir = 4, MAX_ELIXIR = 10, ELIXIR_RATE = 1.0; let elixirAcc = 0;
  let units = []; let playerTowerHP = 1000, aiTowerHP = 1000;

  // card configs (speeds in px/sec)
  const CARD_POOL = [
    {id:'spear', name:'Spearman', cost:2, hp:120, dmg:24, speed:120, range:12, size:10, type:'ground'},
    {id:'knight', name:'Knight', cost:3, hp:320, dmg:70, speed:90, range:12, size:12, type:'ground'},
    {id:'archer', name:'Archer', cost:3, hp:110, dmg:28, speed:140, range:170, size:9, type:'both'},
    {id:'mini', name:'MiniTank', cost:4, hp:460, dmg:95, speed:70, range:14, size:14, type:'ground'},
    {id:'healer', name:'Healer', cost:4, hp:120, dmg:0, speed:100, range:140, size:10, type:'support', heal:30},
    {id:'giant', name:'Giant', cost:5, hp:1200, dmg:85, speed:50, range:16, size:18, type:'building'}
  ];

  // decks & hands
  let playerDeck = [], aiDeck = [], playerHand = [], aiHand = []; const HAND_SIZE = 4;

  function shuffle(a){ return a.slice().sort(()=>Math.random()-0.5); }
  function initHands(){ playerDeck = shuffle(CARD_POOL).concat(shuffle(CARD_POOL)); aiDeck = shuffle(CARD_POOL).concat(shuffle(CARD_POOL)); playerHand = drawMany(playerDeck,HAND_SIZE); aiHand = drawMany(aiDeck,HAND_SIZE); renderHand(); }
  function drawMany(deck,n){ const out=[]; for(let i=0;i<n;i++) out.push(deck[(i)%deck.length]); return out; }

  // -------------------- Unit class --------------------
  class Unit{
    constructor(cfg){ Object.assign(this,cfg); this.maxHp = this.hp; this.attackTimer = 0; this.attackRate = 0.9; this.target = null; }
    update(dt){
      // remove dead in external loop
      // find nearest enemy unit in lane band
      if(!this.target || this.target.hp<=0 || Math.abs(this.target.y - this.y) > 80){ this.target = findNearestEnemy(this); }
      if(this.target){
        const dx = this.target.x - this.x; const dy = this.target.y - this.y; const dist = Math.hypot(dx,dy);
        if(dist <= this.range + this.size + (this.target.size||10)){
          this.attackTimer -= dt; if(this.attackTimer<=0){ this.attackTimer = this.attackRate; if(this.heal){ this.target.hp = Math.min(this.target.maxHp, this.target.hp + this.heal); } else { this.target.hp -= this.dmg; } }
        } else {
          const dirx = dx / (dist || 1);
          this.x += dirx * this.speed * dt;
        }
      } else {
        // move toward enemy tower across bridges: only move horizontally toward enemy side
        const dir = this.side==='player' ? 1 : -1; this.x += dir * this.speed * dt;
      }
    }
    draw(ctx){ ctx.save(); ctx.beginPath(); ctx.fillStyle = this.side==='player' ? '#2dd4bf' : '#fb7185'; ctx.arc(this.x,this.y,this.size,0,Math.PI*2); ctx.fill(); // hp
      const w = this.size*2; const hpw = Math.max(0,Math.min(1,this.hp/this.maxHp))*w; ctx.fillStyle='#081022'; ctx.fillRect(this.x-w/2,this.y-this.size-10,w,6); ctx.fillStyle='#10b981'; ctx.fillRect(this.x-w/2,this.y-this.size-10,hpw,6); ctx.restore(); }
  }

  function findNearestEnemy(unit){ let best=null,bd=Infinity; for(const u of units){ if(u.side===unit.side) continue; if(Math.abs(u.y - unit.y) > 90) continue; const d = Math.hypot(u.x-unit.x,u.y-unit.y); if(d<bd){bd=d;best=u;} } if(best) return best; // no units -> target tower
    return unit.side==='player' ? {x: W - (leftTowerX - TOWER_WIDTH/2), y:unit.y, hp:aiTowerHP, size:20, maxHp:aiTowerHP} : {x: leftTowerX + TOWER_WIDTH/2, y:unit.y, hp:playerTowerHP, size:20, maxHp:playerTowerHP}; }

  // -------------------- Tower positions --------------------
  const TOWER_WIDTH = 58, TOWER_HEIGHT = 120; let leftTowerX = 80;

  // -------------------- Spawning & placement --------------------
  function spawnUnit(card,side,laneX,spawnY){ const x = side==='player' ? leftTowerX + TOWER_WIDTH + 30 : W - leftTowerX - TOWER_WIDTH - 30; // spawn near own tower
    // if laneX provided (bridge center), set spawn x near that bridge so unit will path toward that bridge
    const ux = laneX!==undefined ? (side==='player' ? laneX - 80 : laneX + 80) : x;
    const unit = new Unit({ id: card.id+'@'+Date.now(), name:card.name, side, x:ux, y: spawnY, hp:card.hp, dmg:card.dmg, speed:card.speed, range:card.range, size:card.size, heal:card.heal||0 }); units.push(unit); }

  // Determine chosen bridge lane given click x
  function laneForX(x){ const dLeft = Math.abs(x - leftBridgeX); const dRight = Math.abs(x - rightBridgeX); const dCenter = Math.abs(x - W/2); return dLeft<=dRight && dLeft<=dCenter ? leftBridgeX : (dRight<=dLeft && dRight<=dCenter ? rightBridgeX : W/2); }

  // -------------------- Hand UI --------------------
  const cardsDiv = document.getElementById('cards'); function renderHand(){ cardsDiv.innerHTML=''; playerHand.forEach((c,idx)=>{ const el = document.createElement('div'); el.className='card panel'; el.dataset.idx=idx; el.innerHTML = `<div class="cost">${c.cost}</div><div style="font-weight:800;font-size:15px">${c.name}</div><div style="font-size:12px;color:var(--muted)">${c.id}</div>`; el.addEventListener('click', ()=>onCardClick(idx)); cardsDiv.appendChild(el); }); }

  let pendingCardIndex = null; function onCardClick(idx){ const card = playerHand[idx]; if(!card) return; if(elixir < card.cost) return; pendingCardIndex = idx; canvas.style.cursor='crosshair'; }

  // Click placement: pick lane by x and constrain spawn y to player's spawn area
  canvas.addEventListener('click', (e)=>{ if(pendingCardIndex===null) return; const rect = canvas.getBoundingClientRect(); const cx = (e.clientX - rect.left); const cy = (e.clientY - rect.top); // disallow placing too far forward
    const spawnY = Math.max(spawnZonePlayerY, Math.min(H-60, cy)); const laneX = laneForX(cx); const card = playerHand[pendingCardIndex]; elixir -= card.cost; updateElixirUI(); spawnUnit(card,'player',laneX,spawnY); // replace card
    playerHand[pendingCardIndex] = drawFromDeck(playerDeck); pendingCardIndex=null; canvas.style.cursor='default'; renderHand(); lastPlayedByPlayer = card.id; });

  function drawFromDeck(deck){ return deck[Math.floor(Math.random()*deck.length)]; }

  // -------------------- AI: smarter combos & counters --------------------
  let aiCooldown = 0; let lastPlayedByPlayer = null;
  function aiThink(dt){ aiCooldown -= dt; if(aiCooldown>0) return; // wait
    // Basic strategy: if player played a big unit recently, respond with counters if possible
    const handPlayable = aiHand.filter(c=>c.cost <= elixir + 0.001);
    if(handPlayable.length===0) return; // nothing playable
    // if low towers, go heavy
    if(aiTowerHP < 400 && elixir >= 5){ // aggressive push near center
      playCombo(['giant','healer'], 'aggressive'); aiCooldown = 1.2; return;
    }
    // if player just played a tanky card, play a counter
    if(lastPlayedByPlayer){ const choice = chooseCounterTo(lastPlayedByPlayer, handPlayable); if(choice){ playCardById(choice); aiCooldown = 0.9; return; } }
    // otherwise attempt combos: prefer giant+support if enough elixir
    if(elixir >= 7){ const giant = handPlayable.find(c=>c.id==='giant'); const support = handPlayable.find(c=>c.id==='archer' || c.id==='healer'); if(giant && support){ playCombo([giant.id,support.id],'push'); aiCooldown = 1.4; return; } }
    // fallback: play a cheap unit near the lane that the player used last or random
    const laneX = lastPlayedByPlayer ? laneForX(W*0.5) : (Math.random()<0.5?leftBridgeX:rightBridgeX);
    const chosen = handPlayable[Math.floor(Math.random()*handPlayable.length)]; if(chosen){ playCard(chosen,laneX, H*0.35); aiCooldown = 0.8; }
  }

  function chooseCounterTo(playerCardId, handPlayable){ // simple heuristics
    const mapping = {
      'giant': ['mini','knight','archer'],
      'mini': ['knight','spear'],
      'spear': ['archer','mini'],
      'archer': ['knight','mini'],
      'knight': ['mini','archer']
    };
    const prefs = mapping[playerCardId] || []; for(const p of prefs){ const found = handPlayable.find(c=>c.id===p); if(found) return found.id; } return null;
  }

  function playCombo(ids,reason){ // try to play ids from aiHand if available and affordable
    for(const id of ids){ const card = aiHand.find(c=>c.id===id); if(card && card.cost <= elixir){ playCard(card, Math.random()<0.5?leftBridgeX:rightBridgeX, H*0.35); } }
  }

  function playCardById(id){ const card = aiHand.find(c=>c.id===id); if(card && card.cost <= elixir){ playCard(card, Math.random()<0.5?leftBridgeX:rightBridgeX, H*0.35); } }

  function playCard(card, laneX, spawnY){ elixir -= card.cost; updateElixirUI(); spawnUnit(card,'ai', laneX, spawnY); // replace ai hand card
    const idx = aiHand.indexOf(card); if(idx>=0) aiHand[idx] = drawFromDeck(aiDeck); }

  // -------------------- Game loop --------------------
  let last = performance.now(); let running=false;
  function update(dt){ // elixir regen
    elixir = Math.min(MAX_ELIXIR, elixir + ELIXIR_RATE*dt); updateElixirUI(); // update units
    // update
    for(let i=units.length-1;i>=0;i--){ const u = units[i]; u.update(dt); if(u.hp<=0){ units.splice(i,1); continue; } // tower contact
      if(u.side==='player' && u.x >= W - leftTowerX - TOWER_WIDTH){ aiTowerHP -= u.dmg * dt; document.getElementById('aiTowerHP').textContent = Math.max(0,Math.floor(aiTowerHP)); if(aiTowerHP<=0) endGame('player'); }
      if(u.side==='ai' && u.x <= leftTowerX + TOWER_WIDTH){ playerTowerHP -= u.dmg * dt; document.getElementById('playerTowerHP').textContent = Math.max(0,Math.floor(playerTowerHP)); if(playerTowerHP<=0) endGame('ai'); }
    }
    // ai think
    aiThink(dt);
  }

  function draw(){ ctx.clearRect(0,0,W,H);
    // background gradient
    const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#071428'); g.addColorStop(1,'#041622'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

    // draw river
    ctx.fillStyle = '#063a48'; ctx.fillRect(0,riverY-80,W,160);
    // draw bridges
    ctx.fillStyle = '#8b6a3b'; ctx.fillRect(leftBridgeX - BRIDGE_WIDTH/2, riverY-22, BRIDGE_WIDTH, 44);
    ctx.fillStyle = '#8b6a3b'; ctx.fillRect(rightBridgeX - BRIDGE_WIDTH/2, riverY-22, BRIDGE_WIDTH,44);
    // lanes (subtle)
    ctx.globalAlpha = 0.06; ctx.fillStyle='#ffffff'; ctx.fillRect(0, laneYs[0], W, 2); ctx.fillRect(0, laneYs[2], W, 2); ctx.globalAlpha = 1;

    // towers
    ctx.save(); ctx.fillStyle='#0ea5a4'; ctx.fillRect(leftTowerX, laneYs[1]-TOWER_HEIGHT/2, TOWER_WIDTH, TOWER_HEIGHT); ctx.fillStyle='#081022'; ctx.fillRect(leftTowerX+8, laneYs[1]-TOWER_HEIGHT/2+10, TOWER_WIDTH-16, TOWER_HEIGHT-20); ctx.restore();
    ctx.save(); ctx.fillStyle='#fb7185'; ctx.fillRect(W - leftTowerX - TOWER_WIDTH, laneYs[1]-TOWER_HEIGHT/2, TOWER_WIDTH, TOWER_HEIGHT); ctx.fillStyle='#081022'; ctx.fillRect(W - leftTowerX - TOWER_WIDTH +8, laneYs[1]-TOWER_HEIGHT/2+10, TOWER_WIDTH-16, TOWER_HEIGHT-20); ctx.restore();

    // units
    for(const u of units) u.draw(ctx);

    // tower hp bars
    const barW = 180; const barH = 12; const topPad=12;
    ctx.fillStyle='#072029'; ctx.fillRect(12,topPad,barW,barH); ctx.fillStyle='#10b981'; ctx.fillRect(12,topPad,Math.max(0,playerTowerHP/1000)*barW,barH); ctx.fillStyle='#fff'; ctx.fillText('Player Tower',12,topPad+36);
    ctx.fillStyle='#072029'; ctx.fillRect(W-12-barW,topPad,barW,barH); ctx.fillStyle='#ef4444'; ctx.fillRect(W-12-barW,topPad,Math.max(0,aiTowerHP/1000)*barW,barH); ctx.fillStyle='#fff'; ctx.fillText('AI Tower',W-12-barW,topPad+36);
  }

  function loop(now){ if(!running) return; const dt = Math.min(0.05,(now-last)/1000); last = now; update(dt); draw(); requestAnimationFrame(loop); }

  // -------------------- Elixir UI --------------------
  function updateElixirUI(){ const pct = (elixir/MAX_ELIXIR)*100; document.getElementById('elixirBar').style.width = pct + '%'; document.getElementById('elixirValue').textContent = Math.floor(elixir); }

  // -------------------- Controls --------------------
  document.getElementById('startBtn').addEventListener('click', startGame); document.getElementById('restartBtn').addEventListener('click', startGame);

  function startGame(){ // reset
    playerTowerHP=1000; aiTowerHP=1000; document.getElementById('playerTowerHP').textContent=playerTowerHP; document.getElementById('aiTowerHP').textContent=aiTowerHP; units=[]; elixir=4; updateElixirUI(); initHands(); running=true; document.getElementById('menuOverlay').style.display='none'; document.getElementById('gameOverPopup').style.display='none'; last = performance.now(); requestAnimationFrame(loop); }

  function endGame(winner){ running=false; const popup = document.getElementById('gameOverPopup'); popup.style.display='block'; const title = document.getElementById('resultTitle'); const txt = document.getElementById('resultText'); if(winner==='player'){ title.textContent='Victory!'; txt.textContent='You destroyed the enemy tower.'; } else { title.textContent='Defeat'; txt.textContent='Your tower was destroyed.'; } }

  // -------------------- Background ticks --------------------
  setInterval(()=>{ if(!running) return; elixir = Math.min(MAX_ELIXIR, elixir + 1); updateElixirUI(); }, 1000);
  setInterval(()=>{ if(!running) return; aiThink(0.15); }, 400);

  // expose for debugging
  window.royale = { units, spawnUnit, startGame, endGame };
  </script>
</body>
</html>
