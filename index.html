<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Top-Down Shooter</title>
<style>
body { margin:0; overflow:hidden; }
canvas { background: #222; display: block; margin: 0 auto; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
// Canvas setup
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = 800;
canvas.height = 600;

// Input state
const keys = {};
document.addEventListener('keydown', e => keys[e.key] = true);
document.addEventListener('keyup', e => keys[e.key] = false);

const mouse = {x: 0, y: 0, down: false};
canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
});
canvas.addEventListener('mousedown', e => { mouse.down = true; });
canvas.addEventListener('mouseup', e => { mouse.down = false; });

// Settings
const PLAYER_SPEED = 2.5;
const BOT_SPEED = 2.0;
const BULLET_SPEED = 5;
const RESPAWN_TIME = 2000; // ms
const BOT_SHOOT_INTERVAL = 1000; // ms

// Spawn points (4x4 grid)
const spawnPoints = [];
for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
        spawnPoints.push({x: 100 + j * 200, y: 75 + i * 150});
    }
}

// Walls (rectangle obstacles)
const walls = [
    {x: 390, y: 0, w: 20, h: 600},   // vertical center wall
    {x: 0,   y: 290, w: 800, h: 20}   // horizontal center wall
];

function rectIntersect(ax, ay, aw, ah, bx, by, bw, bh) {
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}

class Character {
    constructor(x, y, color, isBot = false) {
        this.spawnX = x; this.spawnY = y;
        this.x = x; this.y = y;
        this.size = 20;
        this.color = color;
        this.isBot = isBot;
        this.speed = isBot ? BOT_SPEED : PLAYER_SPEED;
        this.dx = 0; this.dy = 0;
        this.alive = true;
        this.respawnTimer = 0;
        this.lastShot = 0;
        this.target = null;
    }
    
    update() {
        const now = Date.now();
        if (!this.alive) {
            if (this.respawnTimer === 0) {
                this.respawnTimer = now + RESPAWN_TIME;
            } else if (now > this.respawnTimer) {
                // Respawn
                this.alive = true;
                this.x = this.spawnX;
                this.y = this.spawnY;
                this.respawnTimer = 0;
            }
            return;
        }
        
        if (this.isBot) {
            // Bot AI: pick target if none or dead
            if (!this.target || !this.target.alive) {
                const others = [player, ...bots].filter(c => c !== this && c.alive);
                if (others.length > 0) {
                    let nearest = null; let minDist = Infinity;
                    others.forEach(c => {
                        const dx = c.x - this.x, dy = c.y - this.y;
                        const d = Math.hypot(dx, dy);
                        if (d < minDist) { minDist = d; nearest = c; }
                    });
                    this.target = nearest;
                }
            }
            let angle;
            if (this.target && this.target.alive) {
                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                const dist = Math.hypot(dx, dy);
                if (dist > 150) {
                    // Wander randomly
                    if (Math.random() < 0.01) {
                        angle = Math.random() * Math.PI * 2;
                        this.dx = Math.cos(angle) * this.speed;
                        this.dy = Math.sin(angle) * this.speed;
                    }
                } else {
                    // Chase target
                    angle = Math.atan2(dy, dx);
                    this.dx = Math.cos(angle) * this.speed;
                    this.dy = Math.sin(angle) * this.speed;
                }
            } else {
                // No target: wander
                if (Math.random() < 0.01) {
                    angle = Math.random() * Math.PI * 2;
                    this.dx = Math.cos(angle) * this.speed;
                    this.dy = Math.sin(angle) * this.speed;
                }
            }
            // Move and collide with walls
            let newX = this.x + this.dx, newY = this.y;
            let collided = walls.some(w => rectIntersect(newX - this.size/2, this.y - this.size/2, this.size, this.size, w.x, w.y, w.w, w.h));
            if (!collided && newX - this.size/2 >= 0 && newX + this.size/2 <= canvas.width) {
                this.x = newX;
            }
            newY = this.y + this.dy;
            collided = walls.some(w => rectIntersect(this.x - this.size/2, newY - this.size/2, this.size, this.size, w.x, w.y, w.w, w.h));
            if (!collided && newY - this.size/2 >= 0 && newY + this.size/2 <= canvas.height) {
                this.y = newY;
            }
            // Bot shooting
            if (this.target && this.target.alive) {
                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                const dist = Math.hypot(dx, dy);
                if (dist < 300 && now - this.lastShot > BOT_SHOOT_INTERVAL) {
                    shootBullet(this, Math.atan2(dy, dx));
                    this.lastShot = now;
                }
            }
        } else {
            // Player movement (WASD)
            let mx = 0, my = 0;
            if (keys['w'] || keys['W']) my = -1;
            if (keys['s'] || keys['S']) my = 1;
            if (keys['a'] || keys['A']) mx = -1;
            if (keys['d'] || keys['D']) mx = 1;
            if (mx && my) {
                mx *= Math.SQRT1_2;
                my *= Math.SQRT1_2;
            }
            this.dx = mx * this.speed;
            this.dy = my * this.speed;
            // Move and collide with walls
            let newX = this.x + this.dx, newY = this.y;
            let collided = walls.some(w => rectIntersect(newX - this.size/2, this.y - this.size/2, this.size, this.size, w.x, w.y, w.w, w.h));
            if (!collided && newX - this.size/2 >= 0 && newX + this.size/2 <= canvas.width) {
                this.x = newX;
            }
            newY = this.y + this.dy;
            collided = walls.some(w => rectIntersect(this.x - this.size/2, newY - this.size/2, this.size, this.size, w.x, w.y, w.w, w.h));
            if (!collided && newY - this.size/2 >= 0 && newY + this.size/2 <= canvas.height) {
                this.y = newY;
            }
            // Player shooting (mouse click)
            if (mouse.down) {
                const dx = mouse.x - this.x;
                const dy = mouse.y - this.y;
                const angle = Math.atan2(dy, dx);
                shootBullet(this, angle);
                mouse.down = false;
            }
        }
    }
    
    draw() {
        if (!this.alive) return;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
    }
}

class Bullet {
    constructor(x, y, angle) {
        this.x = x; this.y = y;
        this.size = 5;
        this.dx = Math.cos(angle) * BULLET_SPEED;
        this.dy = Math.sin(angle) * BULLET_SPEED;
    }
    update() {
        this.x += this.dx;
        this.y += this.dy;
    }
    draw() {
        ctx.fillStyle = 'yellow';
        ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
    }
}

const bullets = [];
function shootBullet(shooter, angle) {
    const b = new Bullet(shooter.x + Math.cos(angle) * shooter.size,
                         shooter.y + Math.sin(angle) * shooter.size, angle);
    bullets.push(b);
}

// Initialize player and bots
const player = new Character(spawnPoints[0].x, spawnPoints[0].y, 'blue', false);
const bots = [];
for (let i = 1; i < spawnPoints.length; i++) {
    bots.push(new Character(spawnPoints[i].x, spawnPoints[i].y, 'red', true));
}

// Game loop
function gameLoop() {
    // Update entities
    player.update();
    bots.forEach(bot => bot.update());
    // Update bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.update();
        // Remove if out of bounds
        if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) {
            bullets.splice(i, 1);
            continue;
        }
        // Remove if hit wall
        if (walls.some(w => rectIntersect(b.x - b.size/2, b.y - b.size/2, b.size, b.size, w.x, w.y, w.w, w.h))) {
            bullets.splice(i, 1);
            continue;
        }
        // Hit player
        if (player.alive && rectIntersect(b.x - b.size/2, b.y - b.size/2, b.size, b.size,
                                          player.x - player.size/2, player.y - player.size/2, player.size, player.size)) {
            player.alive = false;
            player.respawnTimer = Date.now() + RESPAWN_TIME;
            bullets.splice(i, 1);
            continue;
        }
        // Hit bots
        for (const bot of bots) {
            if (bot.alive && rectIntersect(b.x - b.size/2, b.y - b.size/2, b.size, b.size,
                                           bot.x - bot.size/2, bot.y - bot.size/2, bot.size, bot.size)) {
                bot.alive = false;
                bot.respawnTimer = Date.now() + RESPAWN_TIME;
                bullets.splice(i, 1);
                break;
            }
        }
    }
    // Draw
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Draw walls
    ctx.fillStyle = '#555';
    walls.forEach(w => ctx.fillRect(w.x, w.y, w.w, w.h));
    // Draw entities
    player.draw();
    bots.forEach(bot => bot.draw());
    // Draw bullets
    bullets.forEach(b => b.draw());
    requestAnimationFrame(gameLoop);
}
gameLoop();
</script>
</body>
</html>
